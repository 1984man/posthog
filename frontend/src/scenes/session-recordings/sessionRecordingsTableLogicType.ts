// Generated by kea-typegen on Thu, 09 Jun 2022 19:50:09 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic } from 'kea'

import type { PersonUUID } from './sessionRecordingsTableLogic'
import type { RecordingWatchedSource, SessionRecordingFilterType } from '../../lib/utils/eventUsageLogic'
import type { AnyPropertyFilter, FilterType, RecordingDurationFilter, SessionRecordingId, SessionRecordingType, SessionRecordingsResponse } from '../../types'

export interface sessionRecordingsTableLogicType extends Logic {
    actionCreators: {
        reportRecordingsListFetched: (loadTime: number) => {
            type: 'report recordings list fetched (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                loadTime: number
            }
        }
        reportRecordingsListFilterAdded: (filterType: SessionRecordingFilterType) => {
            type: 'report recordings list filter added (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                filterType: SessionRecordingFilterType
            }
        }
        getSessionRecordings: () => {
            type: 'get session recordings (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                value: true
            }
        }
        openSessionPlayer: (
            sessionRecordingId: SessionRecordingId | null,
            source: RecordingWatchedSource
        ) => {
            type: 'open session player (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                sessionRecordingId: string | null
                source: RecordingWatchedSource
            }
        }
        closeSessionPlayer: () => {
            type: 'close session player (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                value: true
            }
        }
        setEntityFilters: (filters: Partial<FilterType>) => {
            type: 'set entity filters (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                filters: Partial<FilterType>
            }
        }
        setPropertyFilters: (filters: AnyPropertyFilter[]) => {
            type: 'set property filters (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                filters: AnyPropertyFilter[]
            }
        }
        loadNext: () => {
            type: 'load next (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                value: true
            }
        }
        loadPrev: () => {
            type: 'load prev (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                value: true
            }
        }
        enableFilter: () => {
            type: 'enable filter (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                value: true
            }
        }
        setOffset: (offset: number) => {
            type: 'set offset (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                offset: number
            }
        }
        setDateRange: (
            incomingFromDate: string | undefined,
            incomingToDate: string | undefined
        ) => {
            type: 'set date range (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                incomingFromDate: string | undefined
                incomingToDate: string | undefined
            }
        }
        setDurationFilter: (durationFilter: RecordingDurationFilter) => {
            type: 'set duration filter (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                durationFilter: RecordingDurationFilter
            }
        }
        getSessionRecordingsSuccess: (
            sessionRecordingsResponse: SessionRecordingsResponse,
            payload?: {
                value: true
            }
        ) => {
            type: 'get session recordings success (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                sessionRecordingsResponse: SessionRecordingsResponse
                payload?: {
                    value: true
                }
            }
        }
        getSessionRecordingsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'get session recordings failure (scenes.session-recordings.sessionRecordingsTableLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
    }
    actionKeys: {
        'report recordings list fetched (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'reportRecordingsListFetched'
        'report recordings list filter added (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'reportRecordingsListFilterAdded'
        'get session recordings (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'getSessionRecordings'
        'open session player (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'openSessionPlayer'
        'close session player (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'closeSessionPlayer'
        'set entity filters (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'setEntityFilters'
        'set property filters (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'setPropertyFilters'
        'load next (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'loadNext'
        'load prev (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'loadPrev'
        'enable filter (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'enableFilter'
        'set offset (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'setOffset'
        'set date range (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'setDateRange'
        'set duration filter (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'setDurationFilter'
        'get session recordings success (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'getSessionRecordingsSuccess'
        'get session recordings failure (scenes.session-recordings.sessionRecordingsTableLogic.*)': 'getSessionRecordingsFailure'
    }
    actionTypes: {
        reportRecordingsListFetched: 'report recordings list fetched (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        reportRecordingsListFilterAdded: 'report recordings list filter added (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        getSessionRecordings: 'get session recordings (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        openSessionPlayer: 'open session player (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        closeSessionPlayer: 'close session player (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        setEntityFilters: 'set entity filters (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        setPropertyFilters: 'set property filters (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        loadNext: 'load next (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        loadPrev: 'load prev (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        enableFilter: 'enable filter (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        setOffset: 'set offset (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        setDateRange: 'set date range (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        setDurationFilter: 'set duration filter (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        getSessionRecordingsSuccess: 'get session recordings success (scenes.session-recordings.sessionRecordingsTableLogic.*)'
        getSessionRecordingsFailure: 'get session recordings failure (scenes.session-recordings.sessionRecordingsTableLogic.*)'
    }
    actions: {
        reportRecordingsListFetched: (loadTime: number) => void
        reportRecordingsListFilterAdded: (filterType: SessionRecordingFilterType) => void
        getSessionRecordings: () => void
        openSessionPlayer: (sessionRecordingId: SessionRecordingId | null, source: RecordingWatchedSource) => void
        closeSessionPlayer: () => void
        setEntityFilters: (filters: Partial<FilterType>) => void
        setPropertyFilters: (filters: AnyPropertyFilter[]) => void
        loadNext: () => void
        loadPrev: () => void
        enableFilter: () => void
        setOffset: (offset: number) => void
        setDateRange: (incomingFromDate: string | undefined, incomingToDate: string | undefined) => void
        setDurationFilter: (durationFilter: RecordingDurationFilter) => void
        getSessionRecordingsSuccess: (
            sessionRecordingsResponse: SessionRecordingsResponse,
            payload?: {
                value: true
            }
        ) => void
        getSessionRecordingsFailure: (error: string, errorObject?: any) => void
    }
    defaults: {
        sessionRecordingsResponse: SessionRecordingsResponse
        sessionRecordingsResponseLoading: boolean
        filterEnabled: boolean
        sessionRecordings: SessionRecordingType[]
        sessionRecordingId: SessionRecordingId | null
        entityFilters: FilterType
        propertyFilters: AnyPropertyFilter[]
        durationFilter: RecordingDurationFilter
        offset: number
        fromDate: null | string
        toDate: string | null
    }
    events: {
        afterMount: () => void
    }
    key: string
    listeners: {
        setEntityFilters: ((
            action: {
                type: 'set entity filters (scenes.session-recordings.sessionRecordingsTableLogic.*)'
                payload: {
                    filters: Partial<FilterType>
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setPropertyFilters: ((
            action: {
                type: 'set property filters (scenes.session-recordings.sessionRecordingsTableLogic.*)'
                payload: {
                    filters: AnyPropertyFilter[]
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setDateRange: ((
            action: {
                type: 'set date range (scenes.session-recordings.sessionRecordingsTableLogic.*)'
                payload: {
                    incomingFromDate: string | undefined
                    incomingToDate: string | undefined
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setDurationFilter: ((
            action: {
                type: 'set duration filter (scenes.session-recordings.sessionRecordingsTableLogic.*)'
                payload: {
                    durationFilter: RecordingDurationFilter
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        loadNext: ((
            action: {
                type: 'load next (scenes.session-recordings.sessionRecordingsTableLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        loadPrev: ((
            action: {
                type: 'load prev (scenes.session-recordings.sessionRecordingsTableLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
    }
    path: ['scenes', 'session-recordings', 'sessionRecordingsTableLogic', '*']
    pathString: 'scenes.session-recordings.sessionRecordingsTableLogic.*'
    props: {
        personUUID?: PersonUUID
        key?: string
    }
    reducer: (
        state: any,
        action: any,
        fullState: any
    ) => {
        sessionRecordingsResponse: SessionRecordingsResponse
        sessionRecordingsResponseLoading: boolean
        filterEnabled: boolean
        sessionRecordings: SessionRecordingType[]
        sessionRecordingId: SessionRecordingId | null
        entityFilters: FilterType
        propertyFilters: AnyPropertyFilter[]
        durationFilter: RecordingDurationFilter
        offset: number
        fromDate: null | string
        toDate: string | null
    }
    reducers: {
        sessionRecordingsResponse: (
            state: SessionRecordingsResponse,
            action: any,
            fullState: any
        ) => SessionRecordingsResponse
        sessionRecordingsResponseLoading: (state: boolean, action: any, fullState: any) => boolean
        filterEnabled: (state: boolean, action: any, fullState: any) => boolean
        sessionRecordings: (state: SessionRecordingType[], action: any, fullState: any) => SessionRecordingType[]
        sessionRecordingId: (state: SessionRecordingId | null, action: any, fullState: any) => SessionRecordingId | null
        entityFilters: (state: FilterType, action: any, fullState: any) => FilterType
        propertyFilters: (state: AnyPropertyFilter[], action: any, fullState: any) => AnyPropertyFilter[]
        durationFilter: (state: RecordingDurationFilter, action: any, fullState: any) => RecordingDurationFilter
        offset: (state: number, action: any, fullState: any) => number
        fromDate: (state: null | string, action: any, fullState: any) => null | string
        toDate: (state: string | null, action: any, fullState: any) => string | null
    }
    selector: (state: any) => {
        sessionRecordingsResponse: SessionRecordingsResponse
        sessionRecordingsResponseLoading: boolean
        filterEnabled: boolean
        sessionRecordings: SessionRecordingType[]
        sessionRecordingId: SessionRecordingId | null
        entityFilters: FilterType
        propertyFilters: AnyPropertyFilter[]
        durationFilter: RecordingDurationFilter
        offset: number
        fromDate: null | string
        toDate: string | null
    }
    selectors: {
        sessionRecordingsResponse: (state: any, props?: any) => SessionRecordingsResponse
        sessionRecordingsResponseLoading: (state: any, props?: any) => boolean
        filterEnabled: (state: any, props?: any) => boolean
        sessionRecordings: (state: any, props?: any) => SessionRecordingType[]
        sessionRecordingId: (state: any, props?: any) => SessionRecordingId | null
        entityFilters: (state: any, props?: any) => FilterType
        propertyFilters: (state: any, props?: any) => AnyPropertyFilter[]
        durationFilter: (state: any, props?: any) => RecordingDurationFilter
        offset: (state: any, props?: any) => number
        fromDate: (state: any, props?: any) => null | string
        toDate: (state: any, props?: any) => string | null
        currentTeamId: (state: any, props?: any) => number | null
        hasPrev: (state: any, props?: any) => boolean
        hasNext: (state: any, props?: any) => boolean
        showFilters: (state: any, props?: any) => boolean
        filterQueryParams: (
            state: any,
            props?: any
        ) => {
            actions: Record<string, any>[] | undefined
            events: Record<string, any>[] | undefined
            properties: AnyPropertyFilter[]
            date_from: string | null
            date_to: string | null
            offset: number
            session_recording_duration: RecordingDurationFilter
        }
    }
    sharedListeners: {}
    values: {
        sessionRecordingsResponse: SessionRecordingsResponse
        sessionRecordingsResponseLoading: boolean
        filterEnabled: boolean
        sessionRecordings: SessionRecordingType[]
        sessionRecordingId: SessionRecordingId | null
        entityFilters: FilterType
        propertyFilters: AnyPropertyFilter[]
        durationFilter: RecordingDurationFilter
        offset: number
        fromDate: null | string
        toDate: string | null
        currentTeamId: number | null
        hasPrev: boolean
        hasNext: boolean
        showFilters: boolean
        filterQueryParams: {
            actions: Record<string, any>[] | undefined
            events: Record<string, any>[] | undefined
            properties: AnyPropertyFilter[]
            date_from: string | null
            date_to: string | null
            offset: number
            session_recording_duration: RecordingDurationFilter
        }
    }
    _isKea: true
    _isKeaWithKey: true
    __keaTypeGenInternalSelectorTypes: {
        hasPrev: (offset: number) => boolean
        hasNext: (sessionRecordingsResponse: SessionRecordingsResponse) => boolean
        showFilters: (
            filterEnabled: boolean,
            entityFilters: FilterType,
            propertyFilters: AnyPropertyFilter[]
        ) => boolean
        filterQueryParams: (
            entityFilters: FilterType,
            fromDate: string | null,
            toDate: string | null,
            offset: number,
            durationFilter: RecordingDurationFilter,
            propertyFilters: AnyPropertyFilter[]
        ) => {
            actions: Record<string, any>[] | undefined
            events: Record<string, any>[] | undefined
            properties: AnyPropertyFilter[]
            date_from: string | null
            date_to: string | null
            offset: number
            session_recording_duration: RecordingDurationFilter
        }
    }
}
