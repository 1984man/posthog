// Generated by kea-typegen on Thu, 09 Jun 2022 19:50:09 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic, BreakPointFunction } from 'kea'

import type { RecordingConsoleLog, RecordingEventType, RecordingEventsFilters, SessionPlayerData, SessionRecordingEvents, SessionRecordingId } from '../../types'
import type { RecordingWatchedSource } from '../../lib/utils/eventUsageLogic'

export interface sessionRecordingLogicType extends Logic {
    actionCreators: {
        setFilters: (filters: Partial<RecordingEventsFilters>) => {
            type: 'set filters (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                filters: Partial<RecordingEventsFilters>
            }
        }
        setSource: (source: RecordingWatchedSource) => {
            type: 'set source (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                source: RecordingWatchedSource
            }
        }
        reportUsage: (
            recordingData: SessionPlayerData,
            loadTime: number
        ) => {
            type: 'report usage (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                recordingData: SessionPlayerData
                loadTime: number
            }
        }
        loadRecordingMeta: (sessionRecordingId?: string) => {
            type: 'load recording meta (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                sessionRecordingId: string | undefined
            }
        }
        loadRecordingSnapshots: (
            sessionRecordingId?: string,
            url?: string
        ) => {
            type: 'load recording snapshots (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                sessionRecordingId: string | undefined
                url: string | undefined
            }
        }
        loadEvents: (url?: string) => {
            type: 'load events (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                url: string | undefined
            }
        }
        loadRecordingMetaSuccess: (
            sessionPlayerData: SessionPlayerData,
            payload?: {
                sessionRecordingId: string | undefined
            }
        ) => {
            type: 'load recording meta success (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                sessionPlayerData: SessionPlayerData
                payload?: {
                    sessionRecordingId: string | undefined
                }
            }
        }
        loadRecordingMetaFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load recording meta failure (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        loadRecordingSnapshotsSuccess: (
            sessionPlayerData: SessionPlayerData,
            payload?: {
                sessionRecordingId: string | undefined
                url: string | undefined
            }
        ) => {
            type: 'load recording snapshots success (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                sessionPlayerData: SessionPlayerData
                payload?: {
                    sessionRecordingId: string | undefined
                    url: string | undefined
                }
            }
        }
        loadRecordingSnapshotsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load recording snapshots failure (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        loadEventsSuccess: (
            sessionEventsData: SessionRecordingEvents | { next: any; events: RecordingEventType[] } | null,
            payload?: {
                url: string | undefined
            }
        ) => {
            type: 'load events success (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                sessionEventsData: SessionRecordingEvents | { next: any; events: RecordingEventType[] } | null
                payload?: {
                    url: string | undefined
                }
            }
        }
        loadEventsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load events failure (scenes.session-recordings.sessionRecordingLogic)'
            payload: {
                error: string
                errorObject?: any
            }
        }
    }
    actionKeys: {
        'set filters (scenes.session-recordings.sessionRecordingLogic)': 'setFilters'
        'set source (scenes.session-recordings.sessionRecordingLogic)': 'setSource'
        'report usage (scenes.session-recordings.sessionRecordingLogic)': 'reportUsage'
        'load recording meta (scenes.session-recordings.sessionRecordingLogic)': 'loadRecordingMeta'
        'load recording snapshots (scenes.session-recordings.sessionRecordingLogic)': 'loadRecordingSnapshots'
        'load events (scenes.session-recordings.sessionRecordingLogic)': 'loadEvents'
        'load recording meta success (scenes.session-recordings.sessionRecordingLogic)': 'loadRecordingMetaSuccess'
        'load recording meta failure (scenes.session-recordings.sessionRecordingLogic)': 'loadRecordingMetaFailure'
        'load recording snapshots success (scenes.session-recordings.sessionRecordingLogic)': 'loadRecordingSnapshotsSuccess'
        'load recording snapshots failure (scenes.session-recordings.sessionRecordingLogic)': 'loadRecordingSnapshotsFailure'
        'load events success (scenes.session-recordings.sessionRecordingLogic)': 'loadEventsSuccess'
        'load events failure (scenes.session-recordings.sessionRecordingLogic)': 'loadEventsFailure'
    }
    actionTypes: {
        setFilters: 'set filters (scenes.session-recordings.sessionRecordingLogic)'
        setSource: 'set source (scenes.session-recordings.sessionRecordingLogic)'
        reportUsage: 'report usage (scenes.session-recordings.sessionRecordingLogic)'
        loadRecordingMeta: 'load recording meta (scenes.session-recordings.sessionRecordingLogic)'
        loadRecordingSnapshots: 'load recording snapshots (scenes.session-recordings.sessionRecordingLogic)'
        loadEvents: 'load events (scenes.session-recordings.sessionRecordingLogic)'
        loadRecordingMetaSuccess: 'load recording meta success (scenes.session-recordings.sessionRecordingLogic)'
        loadRecordingMetaFailure: 'load recording meta failure (scenes.session-recordings.sessionRecordingLogic)'
        loadRecordingSnapshotsSuccess: 'load recording snapshots success (scenes.session-recordings.sessionRecordingLogic)'
        loadRecordingSnapshotsFailure: 'load recording snapshots failure (scenes.session-recordings.sessionRecordingLogic)'
        loadEventsSuccess: 'load events success (scenes.session-recordings.sessionRecordingLogic)'
        loadEventsFailure: 'load events failure (scenes.session-recordings.sessionRecordingLogic)'
    }
    actions: {
        setFilters: (filters: Partial<RecordingEventsFilters>) => void
        setSource: (source: RecordingWatchedSource) => void
        reportUsage: (recordingData: SessionPlayerData, loadTime: number) => void
        loadRecordingMeta: (sessionRecordingId?: string) => void
        loadRecordingSnapshots: (sessionRecordingId?: string, url?: string) => void
        loadEvents: (url?: string) => void
        loadRecordingMetaSuccess: (
            sessionPlayerData: SessionPlayerData,
            payload?: {
                sessionRecordingId: string | undefined
            }
        ) => void
        loadRecordingMetaFailure: (error: string, errorObject?: any) => void
        loadRecordingSnapshotsSuccess: (
            sessionPlayerData: SessionPlayerData,
            payload?: {
                sessionRecordingId: string | undefined
                url: string | undefined
            }
        ) => void
        loadRecordingSnapshotsFailure: (error: string, errorObject?: any) => void
        loadEventsSuccess: (
            sessionEventsData: SessionRecordingEvents | { next: any; events: RecordingEventType[] } | null,
            payload?: {
                url: string | undefined
            }
        ) => void
        loadEventsFailure: (error: string, errorObject?: any) => void
    }
    defaults: {
        filters: Partial<RecordingEventsFilters>
        sessionRecordingId: SessionRecordingId | null
        chunkPaginationIndex: number
        sessionEventsDataLoading: boolean
        source: RecordingWatchedSource
        sessionPlayerData: SessionPlayerData
        sessionPlayerDataLoading: boolean
        sessionEventsData: null | SessionRecordingEvents
    }
    events: {}
    key: undefined
    listeners: {
        reportUsage: ((
            action: {
                type: 'report usage (scenes.session-recordings.sessionRecordingLogic)'
                payload: {
                    recordingData: SessionPlayerData
                    loadTime: number
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
    }
    path: ['scenes', 'session-recordings', 'sessionRecordingLogic']
    pathString: 'scenes.session-recordings.sessionRecordingLogic'
    props: Record<string, unknown>
    reducer: (
        state: any,
        action: any,
        fullState: any
    ) => {
        filters: Partial<RecordingEventsFilters>
        sessionRecordingId: SessionRecordingId | null
        chunkPaginationIndex: number
        sessionEventsDataLoading: boolean
        source: RecordingWatchedSource
        sessionPlayerData: SessionPlayerData
        sessionPlayerDataLoading: boolean
        sessionEventsData: null | SessionRecordingEvents
    }
    reducers: {
        filters: (
            state: Partial<RecordingEventsFilters>,
            action: any,
            fullState: any
        ) => Partial<RecordingEventsFilters>
        sessionRecordingId: (state: SessionRecordingId | null, action: any, fullState: any) => SessionRecordingId | null
        chunkPaginationIndex: (state: number, action: any, fullState: any) => number
        sessionEventsDataLoading: (state: boolean, action: any, fullState: any) => boolean
        source: (state: RecordingWatchedSource, action: any, fullState: any) => RecordingWatchedSource
        sessionPlayerData: (state: SessionPlayerData, action: any, fullState: any) => SessionPlayerData
        sessionPlayerDataLoading: (state: boolean, action: any, fullState: any) => boolean
        sessionEventsData: (
            state: null | SessionRecordingEvents,
            action: any,
            fullState: any
        ) => null | SessionRecordingEvents
    }
    selector: (state: any) => {
        filters: Partial<RecordingEventsFilters>
        sessionRecordingId: SessionRecordingId | null
        chunkPaginationIndex: number
        sessionEventsDataLoading: boolean
        source: RecordingWatchedSource
        sessionPlayerData: SessionPlayerData
        sessionPlayerDataLoading: boolean
        sessionEventsData: null | SessionRecordingEvents
    }
    selectors: {
        filters: (state: any, props?: any) => Partial<RecordingEventsFilters>
        sessionRecordingId: (state: any, props?: any) => SessionRecordingId | null
        chunkPaginationIndex: (state: any, props?: any) => number
        sessionEventsDataLoading: (state: any, props?: any) => boolean
        source: (state: any, props?: any) => RecordingWatchedSource
        sessionPlayerData: (state: any, props?: any) => SessionPlayerData
        sessionPlayerDataLoading: (state: any, props?: any) => boolean
        sessionEventsData: (state: any, props?: any) => null | SessionRecordingEvents
        currentTeamId: (state: any, props?: any) => number | null
        eventsToShow: (state: any, props?: any) => RecordingEventType[]
        eventsApiParams: (
            state: any,
            props?: any
        ) => { person_id: number; after: string; before: string; orderBy: string[] } | null
        orderedConsoleLogs: (state: any, props?: any) => RecordingConsoleLog[]
        areAllSnapshotsLoaded: (state: any, props?: any) => boolean | null
    }
    sharedListeners: {
        showErrorToast: (
            payload: any,
            breakpoint: BreakPointFunction,
            action: {
                type: string
                payload: any
            },
            previousState: any
        ) => void | Promise<void>
    }
    values: {
        filters: Partial<RecordingEventsFilters>
        sessionRecordingId: SessionRecordingId | null
        chunkPaginationIndex: number
        sessionEventsDataLoading: boolean
        source: RecordingWatchedSource
        sessionPlayerData: SessionPlayerData
        sessionPlayerDataLoading: boolean
        sessionEventsData: null | SessionRecordingEvents
        currentTeamId: number | null
        eventsToShow: RecordingEventType[]
        eventsApiParams: { person_id: number; after: string; before: string; orderBy: string[] } | null
        orderedConsoleLogs: RecordingConsoleLog[]
        areAllSnapshotsLoaded: boolean | null
    }
    _isKea: true
    _isKeaWithKey: false
    __keaTypeGenInternalSelectorTypes: {
        eventsToShow: (
            filters: Partial<RecordingEventsFilters>,
            sessionEventsData: SessionRecordingEvents | null
        ) => RecordingEventType[]
        eventsApiParams: (
            sessionPlayerData: SessionPlayerData
        ) => { person_id: number; after: string; before: string; orderBy: string[] } | null
        orderedConsoleLogs: (sessionPlayerData: SessionPlayerData) => RecordingConsoleLog[]
        areAllSnapshotsLoaded: (sessionPlayerData: SessionPlayerData) => boolean | null
    }
}
