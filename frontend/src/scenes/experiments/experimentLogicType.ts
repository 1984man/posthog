// Generated by kea-typegen on Thu, 09 Jun 2022 19:50:15 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic } from 'kea'

import type { ExperimentLogicProps } from './experimentLogic'
import type { AvailableFeature, Breadcrumb, Experiment, ExperimentResults, FilterType, GroupType, InsightShortId, InsightType, MultivariateFlagVariant, SecondaryExperimentMetric, SecondaryMetricResult } from '../../types'
import type { TaxonomicFilterGroupType } from '../../lib/components/TaxonomicFilter/types'
import type { ReactElement } from '../../../../node_modules/@types/react/index.d'

export interface experimentLogicType extends Logic {
    actionCreators: {
        addToExperiments: (experiment: Experiment) => {
            type: 'add to experiments (scenes.experiment.experimentLogic.*)'
            payload: Experiment
        }
        updateExperiments: (experiment: Experiment) => {
            type: 'update experiments (scenes.experiment.experimentLogic.*)'
            payload: Experiment
        }
        setExperiment: (experiment: Experiment) => {
            type: 'set experiment (scenes.experiment.experimentLogic.*)'
            payload: {
                experiment: Experiment
            }
        }
        createExperiment: (
            draft?: boolean,
            runningTime?: number,
            sampleSize?: number
        ) => {
            type: 'create experiment (scenes.experiment.experimentLogic.*)'
            payload: {
                draft: boolean | undefined
                runningTime: number | undefined
                sampleSize: number | undefined
            }
        }
        setExperimentInsightId: (shortId: InsightShortId) => {
            type: 'set experiment insight id (scenes.experiment.experimentLogic.*)'
            payload: {
                shortId: InsightShortId
            }
        }
        createNewExperimentInsight: (filters?: Partial<FilterType>) => {
            type: 'create new experiment insight (scenes.experiment.experimentLogic.*)'
            payload: {
                filters: Partial<FilterType> | undefined
            }
        }
        setFilters: (filters: Partial<FilterType>) => {
            type: 'set filters (scenes.experiment.experimentLogic.*)'
            payload: {
                filters: Partial<FilterType>
            }
        }
        setNewExperimentData: (experimentData: Partial<Experiment>) => {
            type: 'set new experiment data (scenes.experiment.experimentLogic.*)'
            payload: {
                experimentData: Partial<Experiment>
            }
        }
        updateExperimentGroup: (
            variant: Partial<MultivariateFlagVariant>,
            idx: number
        ) => {
            type: 'update experiment group (scenes.experiment.experimentLogic.*)'
            payload: {
                variant: Partial<MultivariateFlagVariant>
                idx: number
            }
        }
        removeExperimentGroup: (idx: number) => {
            type: 'remove experiment group (scenes.experiment.experimentLogic.*)'
            payload: {
                idx: number
            }
        }
        setExperimentInsightType: (insightType: InsightType) => {
            type: 'set experiment insight type (scenes.experiment.experimentLogic.*)'
            payload: {
                insightType: InsightType
            }
        }
        setEditExperiment: (editing: boolean) => {
            type: 'set edit experiment (scenes.experiment.experimentLogic.*)'
            payload: {
                editing: boolean
            }
        }
        setSecondaryMetrics: (secondaryMetrics: SecondaryExperimentMetric[]) => {
            type: 'set secondary metrics (scenes.experiment.experimentLogic.*)'
            payload: {
                secondaryMetrics: SecondaryExperimentMetric[]
            }
        }
        resetNewExperiment: () => {
            type: 'reset new experiment (scenes.experiment.experimentLogic.*)'
            payload: {
                value: true
            }
        }
        launchExperiment: () => {
            type: 'launch experiment (scenes.experiment.experimentLogic.*)'
            payload: {
                value: true
            }
        }
        endExperiment: () => {
            type: 'end experiment (scenes.experiment.experimentLogic.*)'
            payload: {
                value: true
            }
        }
        addExperimentGroup: () => {
            type: 'add experiment group (scenes.experiment.experimentLogic.*)'
            payload: {
                value: true
            }
        }
        archiveExperiment: () => {
            type: 'archive experiment (scenes.experiment.experimentLogic.*)'
            payload: {
                value: true
            }
        }
        loadExperiment: () => {
            type: 'load experiment (scenes.experiment.experimentLogic.*)'
            payload: any
        }
        loadExperimentSuccess: (
            experimentData: Experiment | null,
            payload?: any
        ) => {
            type: 'load experiment success (scenes.experiment.experimentLogic.*)'
            payload: {
                experimentData: Experiment | null
                payload?: any
            }
        }
        loadExperimentFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load experiment failure (scenes.experiment.experimentLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        updateExperiment: (update: Partial<Experiment>) => {
            type: 'update experiment (scenes.experiment.experimentLogic.*)'
            payload: Partial<Experiment>
        }
        updateExperimentSuccess: (
            experimentData: Experiment,
            payload?: Partial<Experiment>
        ) => {
            type: 'update experiment success (scenes.experiment.experimentLogic.*)'
            payload: {
                experimentData: Experiment
                payload?: Partial<Experiment>
            }
        }
        updateExperimentFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'update experiment failure (scenes.experiment.experimentLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        loadExperimentResults: () => {
            type: 'load experiment results (scenes.experiment.experimentLogic.*)'
            payload: any
        }
        loadExperimentResultsSuccess: (
            experimentResults: ExperimentResults | null,
            payload?: any
        ) => {
            type: 'load experiment results success (scenes.experiment.experimentLogic.*)'
            payload: {
                experimentResults: ExperimentResults | null
                payload?: any
            }
        }
        loadExperimentResultsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load experiment results failure (scenes.experiment.experimentLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        loadSecondaryMetricResults: () => {
            type: 'load secondary metric results (scenes.experiment.experimentLogic.*)'
            payload: any
        }
        loadSecondaryMetricResultsSuccess: (
            secondaryMetricResults: any[],
            payload?: any
        ) => {
            type: 'load secondary metric results success (scenes.experiment.experimentLogic.*)'
            payload: {
                secondaryMetricResults: any[]
                payload?: any
            }
        }
        loadSecondaryMetricResultsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load secondary metric results failure (scenes.experiment.experimentLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
    }
    actionKeys: {
        'add to experiments (scenes.experiment.experimentLogic.*)': 'addToExperiments'
        'update experiments (scenes.experiment.experimentLogic.*)': 'updateExperiments'
        'set experiment (scenes.experiment.experimentLogic.*)': 'setExperiment'
        'create experiment (scenes.experiment.experimentLogic.*)': 'createExperiment'
        'set experiment insight id (scenes.experiment.experimentLogic.*)': 'setExperimentInsightId'
        'create new experiment insight (scenes.experiment.experimentLogic.*)': 'createNewExperimentInsight'
        'set filters (scenes.experiment.experimentLogic.*)': 'setFilters'
        'set new experiment data (scenes.experiment.experimentLogic.*)': 'setNewExperimentData'
        'update experiment group (scenes.experiment.experimentLogic.*)': 'updateExperimentGroup'
        'remove experiment group (scenes.experiment.experimentLogic.*)': 'removeExperimentGroup'
        'set experiment insight type (scenes.experiment.experimentLogic.*)': 'setExperimentInsightType'
        'set edit experiment (scenes.experiment.experimentLogic.*)': 'setEditExperiment'
        'set secondary metrics (scenes.experiment.experimentLogic.*)': 'setSecondaryMetrics'
        'reset new experiment (scenes.experiment.experimentLogic.*)': 'resetNewExperiment'
        'launch experiment (scenes.experiment.experimentLogic.*)': 'launchExperiment'
        'end experiment (scenes.experiment.experimentLogic.*)': 'endExperiment'
        'add experiment group (scenes.experiment.experimentLogic.*)': 'addExperimentGroup'
        'archive experiment (scenes.experiment.experimentLogic.*)': 'archiveExperiment'
        'load experiment (scenes.experiment.experimentLogic.*)': 'loadExperiment'
        'load experiment success (scenes.experiment.experimentLogic.*)': 'loadExperimentSuccess'
        'load experiment failure (scenes.experiment.experimentLogic.*)': 'loadExperimentFailure'
        'update experiment (scenes.experiment.experimentLogic.*)': 'updateExperiment'
        'update experiment success (scenes.experiment.experimentLogic.*)': 'updateExperimentSuccess'
        'update experiment failure (scenes.experiment.experimentLogic.*)': 'updateExperimentFailure'
        'load experiment results (scenes.experiment.experimentLogic.*)': 'loadExperimentResults'
        'load experiment results success (scenes.experiment.experimentLogic.*)': 'loadExperimentResultsSuccess'
        'load experiment results failure (scenes.experiment.experimentLogic.*)': 'loadExperimentResultsFailure'
        'load secondary metric results (scenes.experiment.experimentLogic.*)': 'loadSecondaryMetricResults'
        'load secondary metric results success (scenes.experiment.experimentLogic.*)': 'loadSecondaryMetricResultsSuccess'
        'load secondary metric results failure (scenes.experiment.experimentLogic.*)': 'loadSecondaryMetricResultsFailure'
    }
    actionTypes: {
        addToExperiments: 'add to experiments (scenes.experiment.experimentLogic.*)'
        updateExperiments: 'update experiments (scenes.experiment.experimentLogic.*)'
        setExperiment: 'set experiment (scenes.experiment.experimentLogic.*)'
        createExperiment: 'create experiment (scenes.experiment.experimentLogic.*)'
        setExperimentInsightId: 'set experiment insight id (scenes.experiment.experimentLogic.*)'
        createNewExperimentInsight: 'create new experiment insight (scenes.experiment.experimentLogic.*)'
        setFilters: 'set filters (scenes.experiment.experimentLogic.*)'
        setNewExperimentData: 'set new experiment data (scenes.experiment.experimentLogic.*)'
        updateExperimentGroup: 'update experiment group (scenes.experiment.experimentLogic.*)'
        removeExperimentGroup: 'remove experiment group (scenes.experiment.experimentLogic.*)'
        setExperimentInsightType: 'set experiment insight type (scenes.experiment.experimentLogic.*)'
        setEditExperiment: 'set edit experiment (scenes.experiment.experimentLogic.*)'
        setSecondaryMetrics: 'set secondary metrics (scenes.experiment.experimentLogic.*)'
        resetNewExperiment: 'reset new experiment (scenes.experiment.experimentLogic.*)'
        launchExperiment: 'launch experiment (scenes.experiment.experimentLogic.*)'
        endExperiment: 'end experiment (scenes.experiment.experimentLogic.*)'
        addExperimentGroup: 'add experiment group (scenes.experiment.experimentLogic.*)'
        archiveExperiment: 'archive experiment (scenes.experiment.experimentLogic.*)'
        loadExperiment: 'load experiment (scenes.experiment.experimentLogic.*)'
        loadExperimentSuccess: 'load experiment success (scenes.experiment.experimentLogic.*)'
        loadExperimentFailure: 'load experiment failure (scenes.experiment.experimentLogic.*)'
        updateExperiment: 'update experiment (scenes.experiment.experimentLogic.*)'
        updateExperimentSuccess: 'update experiment success (scenes.experiment.experimentLogic.*)'
        updateExperimentFailure: 'update experiment failure (scenes.experiment.experimentLogic.*)'
        loadExperimentResults: 'load experiment results (scenes.experiment.experimentLogic.*)'
        loadExperimentResultsSuccess: 'load experiment results success (scenes.experiment.experimentLogic.*)'
        loadExperimentResultsFailure: 'load experiment results failure (scenes.experiment.experimentLogic.*)'
        loadSecondaryMetricResults: 'load secondary metric results (scenes.experiment.experimentLogic.*)'
        loadSecondaryMetricResultsSuccess: 'load secondary metric results success (scenes.experiment.experimentLogic.*)'
        loadSecondaryMetricResultsFailure: 'load secondary metric results failure (scenes.experiment.experimentLogic.*)'
    }
    actions: {
        addToExperiments: (experiment: Experiment) => void
        updateExperiments: (experiment: Experiment) => void
        setExperiment: (experiment: Experiment) => void
        createExperiment: (draft?: boolean, runningTime?: number, sampleSize?: number) => void
        setExperimentInsightId: (shortId: InsightShortId) => void
        createNewExperimentInsight: (filters?: Partial<FilterType>) => void
        setFilters: (filters: Partial<FilterType>) => void
        setNewExperimentData: (experimentData: Partial<Experiment>) => void
        updateExperimentGroup: (variant: Partial<MultivariateFlagVariant>, idx: number) => void
        removeExperimentGroup: (idx: number) => void
        setExperimentInsightType: (insightType: InsightType) => void
        setEditExperiment: (editing: boolean) => void
        setSecondaryMetrics: (secondaryMetrics: SecondaryExperimentMetric[]) => void
        resetNewExperiment: () => void
        launchExperiment: () => void
        endExperiment: () => void
        addExperimentGroup: () => void
        archiveExperiment: () => void
        loadExperiment: () => void
        loadExperimentSuccess: (experimentData: Experiment | null, payload?: any) => void
        loadExperimentFailure: (error: string, errorObject?: any) => void
        updateExperiment: (update: Partial<Experiment>) => void
        updateExperimentSuccess: (experimentData: Experiment, payload?: Partial<Experiment>) => void
        updateExperimentFailure: (error: string, errorObject?: any) => void
        loadExperimentResults: () => void
        loadExperimentResultsSuccess: (experimentResults: ExperimentResults | null, payload?: any) => void
        loadExperimentResultsFailure: (error: string, errorObject?: any) => void
        loadSecondaryMetricResults: () => void
        loadSecondaryMetricResultsSuccess: (secondaryMetricResults: any[], payload?: any) => void
        loadSecondaryMetricResultsFailure: (error: string, errorObject?: any) => void
    }
    defaults: {
        newExperimentData: Partial<Experiment> | null
        experimentInsightType: InsightType
        experimentInsightId: InsightShortId | null
        editingExistingExperiment: boolean
        experimentData: Experiment | null
        experimentDataLoading: boolean
        experimentResults: ExperimentResults | null
        experimentResultsLoading: boolean
        secondaryMetricResults: SecondaryMetricResult[] | null
        secondaryMetricResultsLoading: boolean
    }
    events: {}
    key: number | 'new'
    listeners: {
        createExperiment: ((
            action: {
                type: 'create experiment (scenes.experiment.experimentLogic.*)'
                payload: {
                    draft: boolean | undefined
                    runningTime: number | undefined
                    sampleSize: number | undefined
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        createNewExperimentInsight: ((
            action: {
                type: 'create new experiment insight (scenes.experiment.experimentLogic.*)'
                payload: {
                    filters: Partial<FilterType> | undefined
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setFilters: ((
            action: {
                type: 'set filters (scenes.experiment.experimentLogic.*)'
                payload: {
                    filters: Partial<FilterType>
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        launchExperiment: ((
            action: {
                type: 'launch experiment (scenes.experiment.experimentLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        endExperiment: ((
            action: {
                type: 'end experiment (scenes.experiment.experimentLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        archiveExperiment: ((
            action: {
                type: 'archive experiment (scenes.experiment.experimentLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setExperimentInsightType: ((
            action: {
                type: 'set experiment insight type (scenes.experiment.experimentLogic.*)'
                payload: {
                    insightType: InsightType
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
    }
    path: ['scenes', 'experiment', 'experimentLogic', '*']
    pathString: 'scenes.experiment.experimentLogic.*'
    props: ExperimentLogicProps
    reducer: (
        state: any,
        action: any,
        fullState: any
    ) => {
        newExperimentData: Partial<Experiment> | null
        experimentInsightType: InsightType
        experimentInsightId: InsightShortId | null
        editingExistingExperiment: boolean
        experimentData: Experiment | null
        experimentDataLoading: boolean
        experimentResults: ExperimentResults | null
        experimentResultsLoading: boolean
        secondaryMetricResults: SecondaryMetricResult[] | null
        secondaryMetricResultsLoading: boolean
    }
    reducers: {
        newExperimentData: (
            state: Partial<Experiment> | null,
            action: any,
            fullState: any
        ) => Partial<Experiment> | null
        experimentInsightType: (state: InsightType, action: any, fullState: any) => InsightType
        experimentInsightId: (state: InsightShortId | null, action: any, fullState: any) => InsightShortId | null
        editingExistingExperiment: (state: boolean, action: any, fullState: any) => boolean
        experimentData: (state: Experiment | null, action: any, fullState: any) => Experiment | null
        experimentDataLoading: (state: boolean, action: any, fullState: any) => boolean
        experimentResults: (state: ExperimentResults | null, action: any, fullState: any) => ExperimentResults | null
        experimentResultsLoading: (state: boolean, action: any, fullState: any) => boolean
        secondaryMetricResults: (
            state: SecondaryMetricResult[] | null,
            action: any,
            fullState: any
        ) => SecondaryMetricResult[] | null
        secondaryMetricResultsLoading: (state: boolean, action: any, fullState: any) => boolean
    }
    selector: (state: any) => {
        newExperimentData: Partial<Experiment> | null
        experimentInsightType: InsightType
        experimentInsightId: InsightShortId | null
        editingExistingExperiment: boolean
        experimentData: Experiment | null
        experimentDataLoading: boolean
        experimentResults: ExperimentResults | null
        experimentResultsLoading: boolean
        secondaryMetricResults: SecondaryMetricResult[] | null
        secondaryMetricResultsLoading: boolean
    }
    selectors: {
        newExperimentData: (state: any, props?: any) => Partial<Experiment> | null
        experimentInsightType: (state: any, props?: any) => InsightType
        experimentInsightId: (state: any, props?: any) => InsightShortId | null
        editingExistingExperiment: (state: any, props?: any) => boolean
        experimentData: (state: any, props?: any) => Experiment | null
        experimentDataLoading: (state: any, props?: any) => boolean
        experimentResults: (state: any, props?: any) => ExperimentResults | null
        experimentResultsLoading: (state: any, props?: any) => boolean
        secondaryMetricResults: (state: any, props?: any) => SecondaryMetricResult[] | null
        secondaryMetricResultsLoading: (state: any, props?: any) => boolean
        currentTeamId: (state: any, props?: any) => number | null
        hasAvailableFeature: (state: any, props?: any) => (feature: AvailableFeature) => boolean
        groupTypes: (state: any, props?: any) => Array<GroupType>
        groupsTaxonomicTypes: (state: any, props?: any) => TaxonomicFilterGroupType[]
        aggregationLabel: (
            state: any,
            props?: any
        ) => (
            groupTypeIndex: number | null | undefined,
            deferToUserWording?: boolean
        ) => {
            singular: string
            plural: string
        }
        experimentId: (state: any, props?: any) => Experiment['id']
        breadcrumbs: (state: any, props?: any) => Breadcrumb[]
        variants: (state: any, props?: any) => MultivariateFlagVariant[]
        taxonomicGroupTypesForSelection: (state: any, props?: any) => TaxonomicFilterGroupType[]
        parsedSecondaryMetrics: (state: any, props?: any) => SecondaryExperimentMetric[]
        minimumDetectableChange: (state: any, props?: any) => number
        minimumSampleSizePerVariant: (state: any, props?: any) => (conversionRate: number) => number
        areResultsSignificant: (state: any, props?: any) => boolean
        significanceBannerDetails: (state: any, props?: any) => string | ReactElement
        recommendedExposureForCountData: (state: any, props?: any) => (baseCountData: number) => number
        expectedRunningTime: (
            state: any,
            props?: any
        ) => (entrants: number, sampleSize: number, duration?: number) => number
        conversionRateForVariant: (state: any, props?: any) => (variant: string) => string
        getIndexForVariant: (state: any, props?: any) => (variant: string, insightType: InsightType) => number
        countDataForVariant: (state: any, props?: any) => (variant: string) => string
        highestProbabilityVariant: (state: any, props?: any) => string | undefined
        areTrendResultsConfusing: (state: any, props?: any) => boolean
    }
    sharedListeners: {}
    values: {
        newExperimentData: Partial<Experiment> | null
        experimentInsightType: InsightType
        experimentInsightId: InsightShortId | null
        editingExistingExperiment: boolean
        experimentData: Experiment | null
        experimentDataLoading: boolean
        experimentResults: ExperimentResults | null
        experimentResultsLoading: boolean
        secondaryMetricResults: SecondaryMetricResult[] | null
        secondaryMetricResultsLoading: boolean
        currentTeamId: number | null
        hasAvailableFeature: (feature: AvailableFeature) => boolean
        groupTypes: Array<GroupType>
        groupsTaxonomicTypes: TaxonomicFilterGroupType[]
        aggregationLabel: (
            groupTypeIndex: number | null | undefined,
            deferToUserWording?: boolean
        ) => {
            singular: string
            plural: string
        }
        experimentId: Experiment['id']
        breadcrumbs: Breadcrumb[]
        variants: MultivariateFlagVariant[]
        taxonomicGroupTypesForSelection: TaxonomicFilterGroupType[]
        parsedSecondaryMetrics: SecondaryExperimentMetric[]
        minimumDetectableChange: number
        minimumSampleSizePerVariant: (conversionRate: number) => number
        areResultsSignificant: boolean
        significanceBannerDetails: string | ReactElement
        recommendedExposureForCountData: (baseCountData: number) => number
        expectedRunningTime: (entrants: number, sampleSize: number, duration?: number) => number
        conversionRateForVariant: (variant: string) => string
        getIndexForVariant: (variant: string, insightType: InsightType) => number
        countDataForVariant: (variant: string) => string
        highestProbabilityVariant: string | undefined
        areTrendResultsConfusing: boolean
    }
    _isKea: true
    _isKeaWithKey: true
    __keaTypeGenInternalSelectorTypes: {
        experimentId: (arg: any) => Experiment['id']
        breadcrumbs: (experimentData: Experiment | null, experimentId: number | 'new') => Breadcrumb[]
        variants: (
            newExperimentData: Partial<Experiment> | null,
            experimentData: Experiment | null
        ) => MultivariateFlagVariant[]
        taxonomicGroupTypesForSelection: (
            newExperimentData: Partial<Experiment> | null,
            groupsTaxonomicTypes: TaxonomicFilterGroupType[]
        ) => TaxonomicFilterGroupType[]
        parsedSecondaryMetrics: (
            newExperimentData: Partial<Experiment> | null,
            experimentData: Experiment | null
        ) => SecondaryExperimentMetric[]
        minimumDetectableChange: (newExperimentData: Partial<Experiment> | null) => number
        minimumSampleSizePerVariant: (minimumDetectableChange: number) => (conversionRate: number) => number
        areResultsSignificant: (experimentResults: ExperimentResults | null) => boolean
        significanceBannerDetails: (experimentResults: ExperimentResults | null) => string | ReactElement
        recommendedExposureForCountData: (minimumDetectableChange: number) => (baseCountData: number) => number
        conversionRateForVariant: (experimentResults: ExperimentResults | null) => (variant: string) => string
        getIndexForVariant: (
            experimentResults: ExperimentResults | null
        ) => (variant: string, insightType: InsightType) => number
        countDataForVariant: (experimentResults: ExperimentResults | null) => (variant: string) => string
        highestProbabilityVariant: (experimentResults: ExperimentResults | null) => string | undefined
        areTrendResultsConfusing: (
            experimentResults: ExperimentResults | null,
            highestProbabilityVariant: string | undefined
        ) => boolean
    }
}
