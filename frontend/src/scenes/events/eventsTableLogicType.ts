// Generated by kea-typegen on Thu, 09 Jun 2022 19:50:09 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic } from 'kea'

import type { ApiError, EventsTableLogicProps, OnFetchEventsSuccess } from './eventsTableLogic'
import type { AnyPropertyFilter, EventType, EventsTableRowItem, PropertyFilter, PropertyGroupFilter } from '../../types'

export interface eventsTableLogicType extends Logic {
    actionCreators: {
        setPollingActive: (pollingActive: boolean) => {
            type: 'set polling active (scenes.events.eventsTableLogic.*)'
            payload: {
                pollingActive: boolean
            }
        }
        setProperties: (properties: AnyPropertyFilter[] | AnyPropertyFilter | PropertyGroupFilter) => {
            type: 'set properties (scenes.events.eventsTableLogic.*)'
            payload: {
                properties: AnyPropertyFilter[]
            }
        }
        fetchEvents: (
            nextParams?: {
                before: string
            } | null
        ) => {
            type: 'fetch events (scenes.events.eventsTableLogic.*)'
            payload: {
                nextParams: {
                    before: string
                } | null
            }
        }
        fetchEventsSuccess: (apiResponse: OnFetchEventsSuccess) => {
            type: 'fetch events success (scenes.events.eventsTableLogic.*)'
            payload: OnFetchEventsSuccess
        }
        fetchNextEvents: () => {
            type: 'fetch next events (scenes.events.eventsTableLogic.*)'
            payload: {
                value: true
            }
        }
        fetchOrPollFailure: (error: ApiError) => {
            type: 'fetch or poll failure (scenes.events.eventsTableLogic.*)'
            payload: {
                error: ApiError
            }
        }
        pollEvents: () => {
            type: 'poll events (scenes.events.eventsTableLogic.*)'
            payload: {
                value: true
            }
        }
        pollEventsSuccess: (events: EventType[]) => {
            type: 'poll events success (scenes.events.eventsTableLogic.*)'
            payload: {
                events: EventType[]
            }
        }
        prependEvents: (events: EventType[]) => {
            type: 'prepend events (scenes.events.eventsTableLogic.*)'
            payload: {
                events: EventType[]
            }
        }
        prependNewEvents: () => {
            type: 'prepend new events (scenes.events.eventsTableLogic.*)'
            payload: {
                value: true
            }
        }
        setSelectedEvent: (selectedEvent: EventType) => {
            type: 'set selected event (scenes.events.eventsTableLogic.*)'
            payload: {
                selectedEvent: EventType
            }
        }
        setPollTimeout: (pollTimeout: number) => {
            type: 'set poll timeout (scenes.events.eventsTableLogic.*)'
            payload: {
                pollTimeout: number
            }
        }
        setEventFilter: (event: string) => {
            type: 'set event filter (scenes.events.eventsTableLogic.*)'
            payload: {
                event: string
            }
        }
        toggleAutomaticLoad: (automaticLoadEnabled: boolean) => {
            type: 'toggle automatic load (scenes.events.eventsTableLogic.*)'
            payload: {
                automaticLoadEnabled: boolean
            }
        }
        noop: (s: any) => {
            type: 'noop (scenes.events.eventsTableLogic.*)'
            payload: any
        }
        startDownload: () => {
            type: 'start download (scenes.events.eventsTableLogic.*)'
            payload: {
                value: true
            }
        }
    }
    actionKeys: {
        'set polling active (scenes.events.eventsTableLogic.*)': 'setPollingActive'
        'set properties (scenes.events.eventsTableLogic.*)': 'setProperties'
        'fetch events (scenes.events.eventsTableLogic.*)': 'fetchEvents'
        'fetch events success (scenes.events.eventsTableLogic.*)': 'fetchEventsSuccess'
        'fetch next events (scenes.events.eventsTableLogic.*)': 'fetchNextEvents'
        'fetch or poll failure (scenes.events.eventsTableLogic.*)': 'fetchOrPollFailure'
        'poll events (scenes.events.eventsTableLogic.*)': 'pollEvents'
        'poll events success (scenes.events.eventsTableLogic.*)': 'pollEventsSuccess'
        'prepend events (scenes.events.eventsTableLogic.*)': 'prependEvents'
        'prepend new events (scenes.events.eventsTableLogic.*)': 'prependNewEvents'
        'set selected event (scenes.events.eventsTableLogic.*)': 'setSelectedEvent'
        'set poll timeout (scenes.events.eventsTableLogic.*)': 'setPollTimeout'
        'set event filter (scenes.events.eventsTableLogic.*)': 'setEventFilter'
        'toggle automatic load (scenes.events.eventsTableLogic.*)': 'toggleAutomaticLoad'
        'noop (scenes.events.eventsTableLogic.*)': 'noop'
        'start download (scenes.events.eventsTableLogic.*)': 'startDownload'
    }
    actionTypes: {
        setPollingActive: 'set polling active (scenes.events.eventsTableLogic.*)'
        setProperties: 'set properties (scenes.events.eventsTableLogic.*)'
        fetchEvents: 'fetch events (scenes.events.eventsTableLogic.*)'
        fetchEventsSuccess: 'fetch events success (scenes.events.eventsTableLogic.*)'
        fetchNextEvents: 'fetch next events (scenes.events.eventsTableLogic.*)'
        fetchOrPollFailure: 'fetch or poll failure (scenes.events.eventsTableLogic.*)'
        pollEvents: 'poll events (scenes.events.eventsTableLogic.*)'
        pollEventsSuccess: 'poll events success (scenes.events.eventsTableLogic.*)'
        prependEvents: 'prepend events (scenes.events.eventsTableLogic.*)'
        prependNewEvents: 'prepend new events (scenes.events.eventsTableLogic.*)'
        setSelectedEvent: 'set selected event (scenes.events.eventsTableLogic.*)'
        setPollTimeout: 'set poll timeout (scenes.events.eventsTableLogic.*)'
        setEventFilter: 'set event filter (scenes.events.eventsTableLogic.*)'
        toggleAutomaticLoad: 'toggle automatic load (scenes.events.eventsTableLogic.*)'
        noop: 'noop (scenes.events.eventsTableLogic.*)'
        startDownload: 'start download (scenes.events.eventsTableLogic.*)'
    }
    actions: {
        setPollingActive: (pollingActive: boolean) => void
        setProperties: (properties: AnyPropertyFilter[] | AnyPropertyFilter | PropertyGroupFilter) => void
        fetchEvents: (
            nextParams?: {
                before: string
            } | null
        ) => void
        fetchEventsSuccess: (apiResponse: OnFetchEventsSuccess) => void
        fetchNextEvents: () => void
        fetchOrPollFailure: (error: ApiError) => void
        pollEvents: () => void
        pollEventsSuccess: (events: EventType[]) => void
        prependEvents: (events: EventType[]) => void
        prependNewEvents: () => void
        setSelectedEvent: (selectedEvent: EventType) => void
        setPollTimeout: (pollTimeout: number) => void
        setEventFilter: (event: string) => void
        toggleAutomaticLoad: (automaticLoadEnabled: boolean) => void
        noop: (s: any) => void
        startDownload: () => void
    }
    defaults: {
        pollingIsActive: boolean
        properties: PropertyFilter[]
        eventFilter: string
        isLoading: boolean
        isLoadingNext: boolean
        events: EventType[]
        hasNext: boolean
        orderBy: string
        selectedEvent: EventType
        newEvents: EventType[]
        highlightEvents: Record<string, boolean>
        pollTimeout: number
        automaticLoadEnabled: boolean
    }
    events: {
        beforeUnmount: () => void
    }
    key: string
    listeners: {
        startDownload: ((
            action: {
                type: 'start download (scenes.events.eventsTableLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setProperties: ((
            action: {
                type: 'set properties (scenes.events.eventsTableLogic.*)'
                payload: {
                    properties: AnyPropertyFilter[]
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setEventFilter: ((
            action: {
                type: 'set event filter (scenes.events.eventsTableLogic.*)'
                payload: {
                    event: string
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        fetchNextEvents: ((
            action: {
                type: 'fetch next events (scenes.events.eventsTableLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        fetchEvents: ((
            action: {
                type: 'fetch events (scenes.events.eventsTableLogic.*)'
                payload: {
                    nextParams: {
                        before: string
                    } | null
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        pollEvents: ((
            action: {
                type: 'poll events (scenes.events.eventsTableLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        prependNewEvents: ((
            action: {
                type: 'prepend new events (scenes.events.eventsTableLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        fetchOrPollFailure: ((
            action: {
                type: 'fetch or poll failure (scenes.events.eventsTableLogic.*)'
                payload: {
                    error: ApiError
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        toggleAutomaticLoad: ((
            action: {
                type: 'toggle automatic load (scenes.events.eventsTableLogic.*)'
                payload: {
                    automaticLoadEnabled: boolean
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
    }
    path: ['scenes', 'events', 'eventsTableLogic', '*']
    pathString: 'scenes.events.eventsTableLogic.*'
    props: EventsTableLogicProps
    reducer: (
        state: any,
        action: any,
        fullState: any
    ) => {
        pollingIsActive: boolean
        properties: PropertyFilter[]
        eventFilter: string
        isLoading: boolean
        isLoadingNext: boolean
        events: EventType[]
        hasNext: boolean
        orderBy: string
        selectedEvent: EventType
        newEvents: EventType[]
        highlightEvents: Record<string, boolean>
        pollTimeout: number
        automaticLoadEnabled: boolean
    }
    reducers: {
        pollingIsActive: (state: boolean, action: any, fullState: any) => boolean
        properties: (state: PropertyFilter[], action: any, fullState: any) => PropertyFilter[]
        eventFilter: (state: string, action: any, fullState: any) => string
        isLoading: (state: boolean, action: any, fullState: any) => boolean
        isLoadingNext: (state: boolean, action: any, fullState: any) => boolean
        events: (state: EventType[], action: any, fullState: any) => EventType[]
        hasNext: (state: boolean, action: any, fullState: any) => boolean
        orderBy: (state: string, action: any, fullState: any) => string
        selectedEvent: (state: EventType, action: any, fullState: any) => EventType
        newEvents: (state: EventType[], action: any, fullState: any) => EventType[]
        highlightEvents: (state: Record<string, boolean>, action: any, fullState: any) => Record<string, boolean>
        pollTimeout: (state: number, action: any, fullState: any) => number
        automaticLoadEnabled: (state: boolean, action: any, fullState: any) => boolean
    }
    selector: (state: any) => {
        pollingIsActive: boolean
        properties: PropertyFilter[]
        eventFilter: string
        isLoading: boolean
        isLoadingNext: boolean
        events: EventType[]
        hasNext: boolean
        orderBy: string
        selectedEvent: EventType
        newEvents: EventType[]
        highlightEvents: Record<string, boolean>
        pollTimeout: number
        automaticLoadEnabled: boolean
    }
    selectors: {
        pollingIsActive: (state: any, props?: any) => boolean
        properties: (state: any, props?: any) => PropertyFilter[]
        eventFilter: (state: any, props?: any) => string
        isLoading: (state: any, props?: any) => boolean
        isLoadingNext: (state: any, props?: any) => boolean
        events: (state: any, props?: any) => EventType[]
        hasNext: (state: any, props?: any) => boolean
        orderBy: (state: any, props?: any) => string
        selectedEvent: (state: any, props?: any) => EventType
        newEvents: (state: any, props?: any) => EventType[]
        highlightEvents: (state: any, props?: any) => Record<string, boolean>
        pollTimeout: (state: any, props?: any) => number
        automaticLoadEnabled: (state: any, props?: any) => boolean
        currentTeamId: (state: any, props?: any) => number | null
        eventsFormatted: (state: any, props?: any) => EventsTableRowItem[]
        exportUrl: (state: any, props?: any) => string
        months: (state: any, props?: any) => any
        minimumQueryDate: (state: any, props?: any) => string
        pollAfter: (state: any, props?: any) => string
    }
    sharedListeners: {}
    values: {
        pollingIsActive: boolean
        properties: PropertyFilter[]
        eventFilter: string
        isLoading: boolean
        isLoadingNext: boolean
        events: EventType[]
        hasNext: boolean
        orderBy: string
        selectedEvent: EventType
        newEvents: EventType[]
        highlightEvents: Record<string, boolean>
        pollTimeout: number
        automaticLoadEnabled: boolean
        currentTeamId: number | null
        eventsFormatted: EventsTableRowItem[]
        exportUrl: string
        months: any
        minimumQueryDate: string
        pollAfter: string
    }
    _isKea: true
    _isKeaWithKey: true
    __keaTypeGenInternalSelectorTypes: {
        eventsFormatted: (events: EventType[], newEvents: EventType[]) => EventsTableRowItem[]
        exportUrl: (
            currentTeamId: number | null,
            eventFilter: string,
            orderBy: string,
            properties: PropertyFilter[],
            minimumQueryDate: string
        ) => string
        months: (arg: any) => any
        minimumQueryDate: (months: any) => string
        pollAfter: (events: EventType[]) => string
    }
}
