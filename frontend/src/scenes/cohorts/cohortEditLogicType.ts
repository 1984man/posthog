// Generated by kea-typegen on Thu, 09 Jun 2022 19:50:04 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic } from 'kea'

import type { CohortLogicProps } from './cohortLogic'
import type { AnyCohortCriteriaType, CohortGroupType, CohortType, FilterLogicalOperator } from '../../types'
import type { DeepPartial, DeepPartialMap, FieldName, ValidationErrorType } from '../../../../node_modules/kea-forms'

export interface cohortEditLogicType extends Logic {
    actionCreators: {
        saveCohort: (cohortParams?: any) => {
            type: 'save cohort (scenes.cohorts.cohortLogicEdit)'
            payload: {
                cohortParams: any
            }
        }
        setCohort: (cohort: CohortType) => {
            type: 'set cohort (scenes.cohorts.cohortLogicEdit)'
            payload: {
                cohort: CohortType
            }
        }
        deleteCohort: () => {
            type: 'delete cohort (scenes.cohorts.cohortLogicEdit)'
            payload: {
                value: true
            }
        }
        fetchCohort: (id: CohortType['id']) => {
            type: 'fetch cohort (scenes.cohorts.cohortLogicEdit)'
            payload: {
                id: number | 'new'
            }
        }
        onCriteriaChange: (
            newGroup: Partial<CohortGroupType>,
            id: string
        ) => {
            type: 'on criteria change (scenes.cohorts.cohortLogicEdit)'
            payload: {
                newGroup: Partial<CohortGroupType>
                id: string
            }
        }
        setPollTimeout: (pollTimeout: number | null) => {
            type: 'set poll timeout (scenes.cohorts.cohortLogicEdit)'
            payload: {
                pollTimeout: number | null
            }
        }
        checkIfFinishedCalculating: (cohort: CohortType) => {
            type: 'check if finished calculating (scenes.cohorts.cohortLogicEdit)'
            payload: {
                cohort: CohortType
            }
        }
        setOuterGroupsType: (type: FilterLogicalOperator) => {
            type: 'set outer groups type (scenes.cohorts.cohortLogicEdit)'
            payload: {
                type: FilterLogicalOperator
            }
        }
        setInnerGroupType: (
            type: FilterLogicalOperator,
            groupIndex: number
        ) => {
            type: 'set inner group type (scenes.cohorts.cohortLogicEdit)'
            payload: {
                type: FilterLogicalOperator
                groupIndex: number
            }
        }
        duplicateFilter: (
            groupIndex: number,
            criteriaIndex?: number
        ) => {
            type: 'duplicate filter (scenes.cohorts.cohortLogicEdit)'
            payload: {
                groupIndex: number
                criteriaIndex: number | undefined
            }
        }
        addFilter: (groupIndex?: number) => {
            type: 'add filter (scenes.cohorts.cohortLogicEdit)'
            payload: {
                groupIndex: number | undefined
            }
        }
        removeFilter: (
            groupIndex: number,
            criteriaIndex?: number
        ) => {
            type: 'remove filter (scenes.cohorts.cohortLogicEdit)'
            payload: {
                groupIndex: number
                criteriaIndex: number | undefined
            }
        }
        setCriteria: (
            newCriteria: AnyCohortCriteriaType,
            groupIndex: number,
            criteriaIndex: number
        ) => {
            type: 'set criteria (scenes.cohorts.cohortLogicEdit)'
            payload: {
                newCriteria: AnyCohortCriteriaType
                groupIndex: number
                criteriaIndex: number
            }
        }
        setCohortValue: (
            key: FieldName,
            value: any
        ) => {
            type: 'set cohort value (scenes.cohorts.cohortLogicEdit)'
            payload: {
                name: FieldName
                value: any
            }
        }
        setCohortValues: (values: DeepPartial<CohortType>) => {
            type: 'set cohort values (scenes.cohorts.cohortLogicEdit)'
            payload: {
                values: DeepPartial<CohortType>
            }
        }
        setCohortManualErrors: (errors: Record<string, any>) => {
            type: 'set cohort manual errors (scenes.cohorts.cohortLogicEdit)'
            payload: {
                errors: Record<string, any>
            }
        }
        touchCohortField: (key: string) => {
            type: 'touch cohort field (scenes.cohorts.cohortLogicEdit)'
            payload: {
                key: string
            }
        }
        resetCohort: (values?: CohortType) => {
            type: 'reset cohort (scenes.cohorts.cohortLogicEdit)'
            payload: {
                values?: CohortType
            }
        }
        submitCohort: () => {
            type: 'submit cohort (scenes.cohorts.cohortLogicEdit)'
            payload: {
                value: boolean
            }
        }
        submitCohortRequest: (cohort: CohortType) => {
            type: 'submit cohort request (scenes.cohorts.cohortLogicEdit)'
            payload: {
                cohort: CohortType
            }
        }
        submitCohortSuccess: (cohort: CohortType) => {
            type: 'submit cohort success (scenes.cohorts.cohortLogicEdit)'
            payload: {
                cohort: CohortType
            }
        }
        submitCohortFailure: (
            error: Error,
            errors: Record<string, any>
        ) => {
            type: 'submit cohort failure (scenes.cohorts.cohortLogicEdit)'
            payload: {
                error: Error
                errors: Record<string, any>
            }
        }
        setCohortSuccess: (
            cohort: CohortType,
            payload?: {
                cohort: CohortType
            }
        ) => {
            type: 'set cohort success (scenes.cohorts.cohortLogicEdit)'
            payload: {
                cohort: CohortType
                payload?: {
                    cohort: CohortType
                }
            }
        }
        setCohortFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'set cohort failure (scenes.cohorts.cohortLogicEdit)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        fetchCohortSuccess: (
            cohort: CohortType,
            payload?: {
                id: number | 'new'
            }
        ) => {
            type: 'fetch cohort success (scenes.cohorts.cohortLogicEdit)'
            payload: {
                cohort: CohortType
                payload?: {
                    id: number | 'new'
                }
            }
        }
        fetchCohortFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'fetch cohort failure (scenes.cohorts.cohortLogicEdit)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        saveCohortSuccess: (
            cohort: CohortType,
            payload?: {
                cohortParams: any
            }
        ) => {
            type: 'save cohort success (scenes.cohorts.cohortLogicEdit)'
            payload: {
                cohort: CohortType
                payload?: {
                    cohortParams: any
                }
            }
        }
        saveCohortFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'save cohort failure (scenes.cohorts.cohortLogicEdit)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        onCriteriaChangeSuccess: (
            cohort: CohortType,
            payload?: {
                newGroup: Partial<CohortGroupType>
                id: string
            }
        ) => {
            type: 'on criteria change success (scenes.cohorts.cohortLogicEdit)'
            payload: {
                cohort: CohortType
                payload?: {
                    newGroup: Partial<CohortGroupType>
                    id: string
                }
            }
        }
        onCriteriaChangeFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'on criteria change failure (scenes.cohorts.cohortLogicEdit)'
            payload: {
                error: string
                errorObject?: any
            }
        }
    }
    actionKeys: {
        'save cohort (scenes.cohorts.cohortLogicEdit)': 'saveCohort'
        'set cohort (scenes.cohorts.cohortLogicEdit)': 'setCohort'
        'delete cohort (scenes.cohorts.cohortLogicEdit)': 'deleteCohort'
        'fetch cohort (scenes.cohorts.cohortLogicEdit)': 'fetchCohort'
        'on criteria change (scenes.cohorts.cohortLogicEdit)': 'onCriteriaChange'
        'set poll timeout (scenes.cohorts.cohortLogicEdit)': 'setPollTimeout'
        'check if finished calculating (scenes.cohorts.cohortLogicEdit)': 'checkIfFinishedCalculating'
        'set outer groups type (scenes.cohorts.cohortLogicEdit)': 'setOuterGroupsType'
        'set inner group type (scenes.cohorts.cohortLogicEdit)': 'setInnerGroupType'
        'duplicate filter (scenes.cohorts.cohortLogicEdit)': 'duplicateFilter'
        'add filter (scenes.cohorts.cohortLogicEdit)': 'addFilter'
        'remove filter (scenes.cohorts.cohortLogicEdit)': 'removeFilter'
        'set criteria (scenes.cohorts.cohortLogicEdit)': 'setCriteria'
        'set cohort value (scenes.cohorts.cohortLogicEdit)': 'setCohortValue'
        'set cohort values (scenes.cohorts.cohortLogicEdit)': 'setCohortValues'
        'set cohort manual errors (scenes.cohorts.cohortLogicEdit)': 'setCohortManualErrors'
        'touch cohort field (scenes.cohorts.cohortLogicEdit)': 'touchCohortField'
        'reset cohort (scenes.cohorts.cohortLogicEdit)': 'resetCohort'
        'submit cohort (scenes.cohorts.cohortLogicEdit)': 'submitCohort'
        'submit cohort request (scenes.cohorts.cohortLogicEdit)': 'submitCohortRequest'
        'submit cohort success (scenes.cohorts.cohortLogicEdit)': 'submitCohortSuccess'
        'submit cohort failure (scenes.cohorts.cohortLogicEdit)': 'submitCohortFailure'
        'set cohort success (scenes.cohorts.cohortLogicEdit)': 'setCohortSuccess'
        'set cohort failure (scenes.cohorts.cohortLogicEdit)': 'setCohortFailure'
        'fetch cohort success (scenes.cohorts.cohortLogicEdit)': 'fetchCohortSuccess'
        'fetch cohort failure (scenes.cohorts.cohortLogicEdit)': 'fetchCohortFailure'
        'save cohort success (scenes.cohorts.cohortLogicEdit)': 'saveCohortSuccess'
        'save cohort failure (scenes.cohorts.cohortLogicEdit)': 'saveCohortFailure'
        'on criteria change success (scenes.cohorts.cohortLogicEdit)': 'onCriteriaChangeSuccess'
        'on criteria change failure (scenes.cohorts.cohortLogicEdit)': 'onCriteriaChangeFailure'
    }
    actionTypes: {
        saveCohort: 'save cohort (scenes.cohorts.cohortLogicEdit)'
        setCohort: 'set cohort (scenes.cohorts.cohortLogicEdit)'
        deleteCohort: 'delete cohort (scenes.cohorts.cohortLogicEdit)'
        fetchCohort: 'fetch cohort (scenes.cohorts.cohortLogicEdit)'
        onCriteriaChange: 'on criteria change (scenes.cohorts.cohortLogicEdit)'
        setPollTimeout: 'set poll timeout (scenes.cohorts.cohortLogicEdit)'
        checkIfFinishedCalculating: 'check if finished calculating (scenes.cohorts.cohortLogicEdit)'
        setOuterGroupsType: 'set outer groups type (scenes.cohorts.cohortLogicEdit)'
        setInnerGroupType: 'set inner group type (scenes.cohorts.cohortLogicEdit)'
        duplicateFilter: 'duplicate filter (scenes.cohorts.cohortLogicEdit)'
        addFilter: 'add filter (scenes.cohorts.cohortLogicEdit)'
        removeFilter: 'remove filter (scenes.cohorts.cohortLogicEdit)'
        setCriteria: 'set criteria (scenes.cohorts.cohortLogicEdit)'
        setCohortValue: 'set cohort value (scenes.cohorts.cohortLogicEdit)'
        setCohortValues: 'set cohort values (scenes.cohorts.cohortLogicEdit)'
        setCohortManualErrors: 'set cohort manual errors (scenes.cohorts.cohortLogicEdit)'
        touchCohortField: 'touch cohort field (scenes.cohorts.cohortLogicEdit)'
        resetCohort: 'reset cohort (scenes.cohorts.cohortLogicEdit)'
        submitCohort: 'submit cohort (scenes.cohorts.cohortLogicEdit)'
        submitCohortRequest: 'submit cohort request (scenes.cohorts.cohortLogicEdit)'
        submitCohortSuccess: 'submit cohort success (scenes.cohorts.cohortLogicEdit)'
        submitCohortFailure: 'submit cohort failure (scenes.cohorts.cohortLogicEdit)'
        setCohortSuccess: 'set cohort success (scenes.cohorts.cohortLogicEdit)'
        setCohortFailure: 'set cohort failure (scenes.cohorts.cohortLogicEdit)'
        fetchCohortSuccess: 'fetch cohort success (scenes.cohorts.cohortLogicEdit)'
        fetchCohortFailure: 'fetch cohort failure (scenes.cohorts.cohortLogicEdit)'
        saveCohortSuccess: 'save cohort success (scenes.cohorts.cohortLogicEdit)'
        saveCohortFailure: 'save cohort failure (scenes.cohorts.cohortLogicEdit)'
        onCriteriaChangeSuccess: 'on criteria change success (scenes.cohorts.cohortLogicEdit)'
        onCriteriaChangeFailure: 'on criteria change failure (scenes.cohorts.cohortLogicEdit)'
    }
    actions: {
        saveCohort: (cohortParams?: any) => void
        setCohort: (cohort: CohortType) => void
        deleteCohort: () => void
        fetchCohort: (id: CohortType['id']) => void
        onCriteriaChange: (newGroup: Partial<CohortGroupType>, id: string) => void
        setPollTimeout: (pollTimeout: number | null) => void
        checkIfFinishedCalculating: (cohort: CohortType) => void
        setOuterGroupsType: (type: FilterLogicalOperator) => void
        setInnerGroupType: (type: FilterLogicalOperator, groupIndex: number) => void
        duplicateFilter: (groupIndex: number, criteriaIndex?: number) => void
        addFilter: (groupIndex?: number) => void
        removeFilter: (groupIndex: number, criteriaIndex?: number) => void
        setCriteria: (newCriteria: AnyCohortCriteriaType, groupIndex: number, criteriaIndex: number) => void
        setCohortValue: (key: FieldName, value: any) => void
        setCohortValues: (values: DeepPartial<CohortType>) => void
        setCohortManualErrors: (errors: Record<string, any>) => void
        touchCohortField: (key: string) => void
        resetCohort: (values?: CohortType) => void
        submitCohort: () => void
        submitCohortRequest: (cohort: CohortType) => void
        submitCohortSuccess: (cohort: CohortType) => void
        submitCohortFailure: (error: Error, errors: Record<string, any>) => void
        setCohortSuccess: (
            cohort: CohortType,
            payload?: {
                cohort: CohortType
            }
        ) => void
        setCohortFailure: (error: string, errorObject?: any) => void
        fetchCohortSuccess: (
            cohort: CohortType,
            payload?: {
                id: number | 'new'
            }
        ) => void
        fetchCohortFailure: (error: string, errorObject?: any) => void
        saveCohortSuccess: (
            cohort: CohortType,
            payload?: {
                cohortParams: any
            }
        ) => void
        saveCohortFailure: (error: string, errorObject?: any) => void
        onCriteriaChangeSuccess: (
            cohort: CohortType,
            payload?: {
                newGroup: Partial<CohortGroupType>
                id: string
            }
        ) => void
        onCriteriaChangeFailure: (error: string, errorObject?: any) => void
    }
    defaults: {
        cohort: CohortType
        pollTimeout: number | null
        isCohortSubmitting: boolean
        showCohortErrors: boolean
        cohortChanged: boolean
        cohortTouches: Record<string, boolean>
        cohortManualErrors: Record<string, any>
        cohortLoading: boolean
    }
    events: {}
    key: number | 'new'
    listeners: {
        deleteCohort: ((
            action: {
                type: 'delete cohort (scenes.cohorts.cohortLogicEdit)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        checkIfFinishedCalculating: ((
            action: {
                type: 'check if finished calculating (scenes.cohorts.cohortLogicEdit)'
                payload: {
                    cohort: CohortType
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
    }
    path: ['scenes', 'cohorts', 'cohortLogicEdit']
    pathString: 'scenes.cohorts.cohortLogicEdit'
    props: CohortLogicProps
    reducer: (
        state: any,
        action: any,
        fullState: any
    ) => {
        cohort: CohortType
        pollTimeout: number | null
        isCohortSubmitting: boolean
        showCohortErrors: boolean
        cohortChanged: boolean
        cohortTouches: Record<string, boolean>
        cohortManualErrors: Record<string, any>
        cohortLoading: boolean
    }
    reducers: {
        cohort: (state: CohortType, action: any, fullState: any) => CohortType
        pollTimeout: (state: number | null, action: any, fullState: any) => number | null
        isCohortSubmitting: (state: boolean, action: any, fullState: any) => boolean
        showCohortErrors: (state: boolean, action: any, fullState: any) => boolean
        cohortChanged: (state: boolean, action: any, fullState: any) => boolean
        cohortTouches: (state: Record<string, boolean>, action: any, fullState: any) => Record<string, boolean>
        cohortManualErrors: (state: Record<string, any>, action: any, fullState: any) => Record<string, any>
        cohortLoading: (state: boolean, action: any, fullState: any) => boolean
    }
    selector: (state: any) => {
        cohort: CohortType
        pollTimeout: number | null
        isCohortSubmitting: boolean
        showCohortErrors: boolean
        cohortChanged: boolean
        cohortTouches: Record<string, boolean>
        cohortManualErrors: Record<string, any>
        cohortLoading: boolean
    }
    selectors: {
        cohort: (state: any, props?: any) => CohortType
        pollTimeout: (state: any, props?: any) => number | null
        isCohortSubmitting: (state: any, props?: any) => boolean
        showCohortErrors: (state: any, props?: any) => boolean
        cohortChanged: (state: any, props?: any) => boolean
        cohortTouches: (state: any, props?: any) => Record<string, boolean>
        cohortManualErrors: (state: any, props?: any) => Record<string, any>
        cohortLoading: (state: any, props?: any) => boolean
        cohortTouched: (state: any, props?: any) => boolean
        cohortValidationErrors: (state: any, props?: any) => DeepPartialMap<CohortType, ValidationErrorType>
        cohortAllErrors: (state: any, props?: any) => Record<string, any>
        cohortHasErrors: (state: any, props?: any) => boolean
        cohortErrors: (state: any, props?: any) => DeepPartialMap<CohortType, ValidationErrorType>
        isCohortValid: (state: any, props?: any) => boolean
        newCohortFiltersEnabled: (state: any, props?: any) => boolean
    }
    sharedListeners: {}
    values: {
        cohort: CohortType
        pollTimeout: number | null
        isCohortSubmitting: boolean
        showCohortErrors: boolean
        cohortChanged: boolean
        cohortTouches: Record<string, boolean>
        cohortManualErrors: Record<string, any>
        cohortLoading: boolean
        cohortTouched: boolean
        cohortValidationErrors: DeepPartialMap<CohortType, ValidationErrorType>
        cohortAllErrors: Record<string, any>
        cohortHasErrors: boolean
        cohortErrors: DeepPartialMap<CohortType, ValidationErrorType>
        isCohortValid: boolean
        newCohortFiltersEnabled: boolean
    }
    _isKea: true
    _isKeaWithKey: true
    __keaTypeGenInternalSelectorTypes: {
        newCohortFiltersEnabled: (
            featureFlags: import('/Users/marius/Projects/PostHog/posthog/frontend/src/lib/logic/featureFlagLogic').FeatureFlagsSet
        ) => boolean
    }
}
